# hls.py
# Code to interface with the Vivado HLS tool
import os
import xml.etree.ElementTree as ET

# Given a layer name and a path to an implementation of that layer,
# calls vivado_hls to synthesize it.
def synthesize_layer(layer_name, impl_path):
   print("Synthesizing layer implementation at {}".format(impl_path))
   cwd = os.getcwd()
   os.chdir(impl_path)
   os.system('vivado_hls -f {}.tcl'.format(layer_name))
   os.chdir(cwd)
   print("Done.")


def read_report_xml(xml_report_filepath):
   tree = ET.parse(xml_report_filepath)
   return tree.getroot()

def GetWorstCaseLatency(report_xml):
   return int(report_xml.find('PerformanceEstimates').find('SummaryOfOverallLatency').find('Worst-caseLatency').text)

def GetCostInfo(report_xml):
   resources = report_xml.find('AreaEstimates').find('Resources')
   available_resources = report_xml.find('AreaEstimates').find('AvailableResources')
   cost = {}
   cost_factors = [('bram', 'BRAM_18K'), ('dsp', 'DSP48E'), ('ff', 'FF'), ('lut', 'LUT')]
   for name, rpt_name in cost_factors:
      cost[name] = int(resources.find(rpt_name)) / int(available_resources.find(rpt_name))
   return cost

# Parse and analyze the reports after synthesis of a layer completes.
# The top-level report will contain cost info and overall latency info
# And it will tell us all the functions inside the dataflow-optimized loop.
# We can then read the reports of all the sub-functions to get their latencies
# and initiation intervals.
#
# This function returns a dictionary summarizing the results. The contents of 
# the dictionary are as follows:
#
#  - latency: The total number of cycles this iteration takes.
#  - cost_info: Another dictionary summarizing the resource cost
#  - subfunctions: A list that summarizes the subfunctions within the top loop.
#        Every element is a dictionary with this format:
#        - name: The name of the subfunction
#        - latency: The latency of the subfunction
#        - ii: The initiation interval of the subfunction
#
# Additionally, a summary file with this data will be generated in the 
# implementation's root directory.
def analyze_reports(layer_name, impl_dir):

   # First, copy the report directory to the implementation root directory,
   # and delete everything else generated by the HLS tool. This is to save
   # disk space since the HLS tool can generate several MB worth of data
   # per implementation. All we really want is the reports.
   hls_proj_dir = os.path.join(impl_dir, '{}_prj'.format(layer_name))
   old_report_dir = os.path.join(hls_proj_dir, '/solution1/syn/report')
   os.system('cp -R {} {}'.format(old_report_dir, impl_dir)
   report_dir = os.path.join(impl_dir, 'report')
   # Delete everything generated by the HLS tool
   os.system('rm -rf {}'.format(hls_proj_dir))

   # Now we want to analyze the reports.
   # First we must read the top-level report
   # Then we need to read the reports for all of the sub-functions.
   # The top-level report file is named "(layer_name)_csynth_report.xml"
   top_level_rpt_filepath = os.path.join(report_dir, '{}_csynth.xml'.format(layer_name))
   top_level_xml = read_report_xml(top_level_rpt_filepath)

   top_latency   = GetWorstCaseLatency(top_level_xml)
   top_cost_info = GetCostInfo(top_level_xml)

# Top-level function called from scale-cnn.py to explore the different
# implementations for a layer.
#
# For each implementation, it synthesizes the layer and parses the report.
# Then it will analyze the results of all the implementations and report a summary.
def explore_layer_implementations(layer_spec, impl_list_path)

   # Read the file with the implementation paths to explore.
   impl_dirs = []
   with open(impl_list_path, 'r') as f:
      lines = f.readlines()
      for line in line:
         impl_dirs.append(line.rstrip('\n'))

   print("Exploring {} layer implementations.".format(len(impl_dirs)))

   layer_name = layer_spec['layer_name']

   # For each implementation...
   for impl_dir in impl_dirs:
      if not os.path.isdir(impl_dir):
         raise Exception('Invalid implementation path at {}'.format(impl_dir))

      # Synthesize the layer
      synthesize_layer(layer_name, impl_dir)

      # Parse the reports to get performance and cost info
      analyze_reports(impl_dir)
